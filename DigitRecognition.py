# -*- coding: utf-8 -*-
"""Базовый блок | Интеграция нейронной сети на ДЕМО-ПАНЕЛЬ | ДЗ Lite | УИИ.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16f63frLlg-SuGv86411bjO6s7BXamYtY
"""

#Модули
from tensorflow.keras.datasets import mnist
from tensorflow.keras.layers import Dense
from tensorflow.keras.models import Sequential
from tensorflow.keras import utils
from tensorflow.keras.layers import Dense, Conv2D, MaxPooling2D, Flatten, Dropout, BatchNormalization
from tensorflow.keras.optimizers import Adam
import os
from google.colab import drive
import numpy as np
import matplotlib.pyplot as plt

#Загрузка из облака данных mnist
(x_train, y_train), (x_test, y_test) = mnist.load_data()

#Вывод формы данных для обучения
print(x_train.shape, y_train.shape)

#Проверка данных
n = 150
plt.imshow(x_train[n], cmap ='gray')
plt.show()
#Вывод метки класса для n-ого изображения
print('Метка:', y_train[n])

#reshape
x_train = x_train.reshape(x_train.shape[0], 28,28,1)
x_test = x_test.reshape(x_test.shape[0], 28,28,1)
print(f'Обучающая выборка: {x_train.shape}')
print(f'Тестовая выборка: {x_test.shape}')

#one_hot_encoding
CLASS_COUNT = 10
y_train = utils.to_categorical(y_train, CLASS_COUNT)
y_test = utils.to_categorical(y_test, CLASS_COUNT)
print(y_train[0])

model = Sequential()
model.add(BatchNormalization(input_shape=(28,28,1)))
model.add(Conv2D(32, (3,3), padding = 'same', activation='relu'))
model.add(Conv2D(32, (3,3), padding = 'same', activation='relu'))
model.add(MaxPooling2D(pool_size=(2,2)))
model.add(Dropout(0.25))
model.add(Flatten())
model.add(Dense(256, activation='relu'))
model.add(Dropout(0.25))
model.add(Dense(10, activation='softmax'))
model.compile(loss = 'categorical_crossentropy', optimizer = 'adam', metrics = ['accuracy'])
model.summary()

#Обучаем сеть
history = model.fit(x_train, y_train, batch_size=128, epochs=15, validation_data=(x_test, y_test), verbose=1)
# Отображаем график точности обучения

plt.plot(history.history['accuracy'],
         label='Доля верных ответов на обучающем наборе')
plt.plot(history.history['val_accuracy'],
         label='Доля верных ответов на проверочном наборе')
plt.xlabel('Эпоха обучения')
plt.ylabel('Доля верных ответов')
plt.legend()
plt.show()

model.save('model_mnist.h5')

from tensorflow.keras.models import load_model
model = load_model('model_mnist.h5')

import gdown

gdown.download('https://storage.yandexcloud.net/aiueducation/Content/base/l6/0-9.zip', None, quiet=True)

!unzip -q 0-9.zip

# Загрузка изображения
from PIL import Image
test_path = '/content/0-9/2.jpg'
img_width, img_height = 28, 28
img = Image.open(test_path)
plt.imshow(img, cmap='gray')
plt.show()

#Конвертация цветов
img = 255 - np.array(img)
plt.imshow(img, cmap = 'gray')
img[img<50] = 0
plt.imshow(img, cmap='gray')
plt.show()

# Подготовка изображения для подачи в НС

import numpy as np

img = Image.open(test_path).convert('L').resize((img_width, img_height)) # Изменение размерности для соответсвия входному слою

# Конвертируем цвета
img = 255 - np.array(img)

# Убраем шум
img[img<50] = 0

plt.imshow(img, cmap='gray')
plt.show()

image = img.reshape(-1, 28, 28, 1)

# Распознавание изображения нейросетью
pred = model.predict(image)
print('Результат распознавания:')
print(pred[0][1])

for i in range(10):
    print('Цифра ', str(i), ' ', round(100*pred[0][i], 2), '%')

print()
cls_image = np.argmax(model.predict(image))
print('Изображен(а): ', cls_image)

def predict(img_path='./test_image_1.jpg', model_path='./model_mnist.h5'):

    from tensorflow.keras.models import load_model

    model = load_model(model_path)

    img_width, img_height = 28, 28

    img = Image.open(img_path).convert('L').resize((img_width, img_height))
    img = 255 - np.array(img)
    img[img<50] = 0

    image = img.reshape(-1, 28, 28, 1)
    cls_image = np.argmax(model.predict(image))

    print(cls_image)

predict(img_path='0-9/6.jpg')

#Скрипт
# Поместим в переменную код, который будет сохранен в модуль, он же скрипт

text_code = '''
from PIL import Image
import numpy as np

def predict(img_path='./test_image_1.jpg', model_path='./model_mnist.h5'):

    from tensorflow.keras.models import load_model

    model = load_model(model_path)

    img_width, img_height = 28, 28

    img = Image.open(test_path).convert('L').resize((img_width, img_height))
    img = 255 - np.array(img)
    img[img<50] = 0

    image = img.reshape(-1, 28, 28, 1)
    cls_image = np.argmax(model.predict(image))

    print(cls_image)

'''

# Запись содержимого переменной в скрипт

with open('script.py', 'w') as f:  # Создание / открытие файла
  f.write(text_code)               # Запись в файл содержание переменной text

from shutil import copyfile         # Библиотека для работы с файлами

for i in range(10):
    copyfile('/content/0-9/'+str(i)+'.jpg', '/content/'+str(i)+'.jpg')

label_txt = '''

0
1
2
3
4
5
6
7
8
9

'''

# Создание / открытие файла

with open('label.txt', 'w') as f:
  f.write(label_txt.strip())       # Запись в файл переменной text

# Список всех файлов

import os
integrate_files = ['model_mnist.h5', 'script.py', 'label.txt', *[f'{i}.jpg' for i in range(10)]]

from zipfile import ZipFile as Zip           # Для работы с zip архивами

zipArchive = Zip('/content/archive.zip', 'w')         # Открытие файла, если такого не существует - будет создан новый

for file in integrate_files:                 # Проход по всем нужным файлам
  if os.path.exists(file):                   # Если файл существует
    zipArchive.write(file)                   # То добавление в архив
  else:
    print(f'Файл {file} отсутствует!')       # Иначе вывод на экран названия отсутствующего файла

zipArchive.close()

from google.colab import files               # Функция для скачивания данных на локальный компьютер

files.download(filename='archive.zip')       # Скачивание готового архива

print('Архив загружен')